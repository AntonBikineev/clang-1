// -*- C++ -*-

#ifndef CPPX_META
#define CPPX_META

#include <cppx/traits.hpp>
#include <cppx/tuple.hpp>

namespace cppx
{
namespace meta
{
inline namespace v1
{

template<typename T> struct is_observable_trait;

template<typename T> struct is_variable_trait;
template<typename T> struct is_function_trait;
template<typename T> struct is_member_variable_trait;
template<typename T> struct is_member_function_trait;
template<typename T> struct is_constructor_trait;
template<typename T> struct is_destructor_trait;
template<typename T> struct is_variable_or_field_trait;
template<typename T> struct is_function_or_method_trait;

// The type of a reflected AST node.
using reflection_t = std::intptr_t;

// Reflections for all traits
template<reflection_t X>
struct decl {
  static constexpr void print() {
    return __reflect_print(X);
  }
  static constexpr decl_traits traits() {
    return decl_traits(__reflect_traits(X));
  }
};

// A reflection of an internal entity. 
template<reflection_t X>
struct internal {
};

// A helper class that provides support for named entities.
template<reflection_t X>
struct named : decl<X> {
  static constexpr char const* name() {
    return __reflect_name(X);
  }
  static constexpr char const* qualified_name() {
    return __reflect_qualified_name(X);
  }

  static constexpr auto declaration_context() {
    return __reflect_declaration_context(X);
  }
  static constexpr auto lexical_context() {
    return __reflect_declaration_context(X);
  }

  static constexpr linkage_kind linkage() {
    return decl<X>::traits().linkage;
  }
  static constexpr bool has_linkage() {
    return linkage() != no_linkage;
  }
  static constexpr bool has_external_linkage() {
    return linkage() == external_linkage;
  }
  static constexpr bool has_internal_linkage() {
    return linkage() == internal_linkage;
  }

  static constexpr access_kind access() {
    return decl<X>::traits().access;
  }
  static constexpr bool has_access() {
    return access() != no_access;
  }
  static constexpr bool is_public() {
    return access() == public_access;
  }
  static constexpr bool is_private() {
    return access() == private_access;
  }
  static constexpr bool is_protected() {
    return access() == protected_access;
  }

  static constexpr void set_access(access_kind k) {
    __modify_access(X, k);
  }
  static constexpr void make_public() {
    __modify_access(X, public_access);
  }
  static constexpr void make_private() {
    __modify_access(X, private_access);
  }
  static constexpr void make_protected() {
    __modify_access(X, protected_access);
  }
};

// A helper class that provides access to members of a scope declaration.
//
// Scoped declarations are also tuples over their members.
template<reflection_t X>
struct scope
{
  struct member_info
  {
    static constexpr std::size_t size() {
      return __reflect_num_members(X);
    }
    template<std::size_t I>
    static constexpr auto get() {
      return __reflect_member(X, I);
    }
  };

  using member_tuple = filtered_tuple<member_info, is_observable_trait>;

  static constexpr member_tuple members() {
    return {};
  }

  static constexpr std::size_t size() {
    return member_tuple::size();
  }
  static constexpr bool empty() {
    return member_tuple::empty();
  }
};

// Returns the Ith element in the filtered tuple.
template<std::size_t I, reflection_t X>
constexpr auto
get(scope<X> const& t)
{
  return get<I>(t.members());
}

// Returns the Ith element in the filtered tuple as a constant expression.
template<std::size_t I, reflection_t X>
constexpr auto
cget(scope<X> const& t)
{
  return get<I>(t.members());
}


// Reflects the current translation unit.
template<reflection_t X>
struct tu : scope<X>
{
};

// Reflects a namespace.
template<reflection_t X>
struct ns : named<X>, scope<X>
{
  static constexpr namespace_traits traits() {
    return namespace_traits(__reflect_traits(X));
  }
  static constexpr bool is_inline() {
    return traits().is_inline;
  }
};

// Base class of the type hierarchy.
template<reflection_t X>
struct type : named<X>
{
};

// All user-defined types define a scope.
template<reflection_t X>
struct user_defined_type : type<X>, scope<X>
{
};

// A useful base class for class and union types.
template<reflection_t X>
struct member_type : user_defined_type<X>
{
  using member_info = typename scope<X>::member_info;
  using var_tuple = filtered_tuple<member_info, is_variable_or_field_trait>;
  using memvar_tuple = filtered_tuple<member_info, is_member_variable_trait>;
  using svar_tuple = filtered_tuple<member_info, is_variable_trait>;
  using fn_field = filtered_tuple<member_info, is_function_or_method_trait>;
  using memfn_tuple = filtered_tuple<member_info, is_member_function_trait>;
  using ctor_tuple = filtered_tuple<member_info, is_constructor_trait>;
  using dtor_tuple = filtered_tuple<member_info, is_destructor_trait>;
  using sfn_tuple = filtered_tuple<member_info, is_function_trait>;

  static constexpr class_traits traits() {
    return class_traits(__reflect_traits(X));
  }

  static constexpr bool is_complete() {
    return traits().is_complete;
  }

  static constexpr var_tuple variables() {
    return {};
  }
  static constexpr memvar_tuple member_variables() {
    return {};
  }
  static constexpr svar_tuple static_variables() {
    return {};
  }
  static constexpr fn_field functions() {
    return {};
  }
  static constexpr memfn_tuple member_functions() {
    return {};
  }
  static constexpr ctor_tuple constructors() {
    return {};
  }
  static constexpr dtor_tuple destructors() {
    return {};
  }
  static constexpr bool has_destructor() {
    return !destructors().empty();
  }
  static constexpr auto destructor() {
    return cget<0>(destructors());
  }
  static constexpr sfn_tuple static_functions() {
    return {};
  }
};

template<reflection_t X>
struct class_type : member_type<X>
{
  static constexpr bool is_polymorphic() {
    return member_type<X>::traits().is_polymorphic;
  }
  static constexpr bool is_abstract() {
    return member_type<X>::traits().is_abstract;
  }
  static constexpr bool is_final() {
    return member_type<X>::traits().is_final;
  }
  static constexpr bool is_empty() {
    return member_type<X>::traits().is_empty;
  }
};

template<reflection_t X>
struct union_type : member_type<X>
{
  // TODO: Are there any interesting traits here?
};

template<reflection_t X>
struct enum_type : user_defined_type<X>
{
  static constexpr enum_traits traits() {
    return enum_traits(__reflect_traits(X));
  }

  static constexpr bool is_scoped() {
    return traits().is_scoped;
  }

  static constexpr bool is_complete() {
    return traits().is_complete;
  }
};

// A typed entity is an entity described by a type: objects, references,
// and functions (and presumably also values?). Note that an expression
// is not an entity.
template<reflection_t X>
struct typed
{
  static constexpr auto type() {
    return __reflect_type(X);
  }

  static constexpr auto type_name() {
    return type().name();
  }
};

template<reflection_t X>
struct variable : named<X>, typed<X>
{
  static constexpr variable_traits traits() {
    return variable_traits(__reflect_traits(X));
  }

  static constexpr storage_kind storage() {
    return traits().storage;
  }
  static constexpr bool has_static_storage() {
    return storage() == static_storage;
  }
  static constexpr bool has_automatic_storage() {
    return storage() == automatic_storage;
  }
  static constexpr bool has_thread_storage() {
    return storage() == thread_storage;
  }

  static constexpr bool is_inline() {
    return traits().is_inline;
  }
  static constexpr bool is_constexpr() {
    return decl<X>::is_constexpr;
  }

  static constexpr auto pointer() {
    return __reflect_pointer(X);
  }
};

template<reflection_t X>
struct function : named<X>, typed<X>
{
  struct parm_info
  {
    static constexpr std::size_t size() {
      return __reflect_num_parameters(X);
    }

    template<std::size_t I>
    static constexpr auto get() {
      return __reflect_parameter(X, I);
    }
  };

  static constexpr function_traits traits() {
    return function_traits(__reflect_traits(X));
  }

  static constexpr bool is_constexpr() {
    return traits().is_constexpr;
  }
  static constexpr bool is_noexcept() {
    return traits().is_noexcept;
  }

  static constexpr bool is_defined() {
    return traits().is_defined;
  }
  static constexpr bool is_inline() {
    static_assert(is_defined());
    return traits().is_inline;
  }
  static constexpr bool is_deleted() {
    static_assert(is_defined());
    return traits().is_deleted;
  }

  static constexpr reflected_tuple<parm_info> parameters() {
    return {};
  }

  static constexpr auto pointer() {
    return __reflect_pointer(X);
  }
};

// A helper class for member functions.
template<reflection_t X>
struct method : named<X>, typed<X> {
  static constexpr method_traits traits() {
    return method_traits(__reflect_traits(X));
  }

  static constexpr bool is_noexcept() {
    return traits().is_noexcept;
  }

  static constexpr bool is_defined() {
    return traits().is_defined;
  }
  static constexpr bool is_inline() {
    static_assert(is_defined());
    return traits().is_inline;
  }
  static constexpr bool is_deleted() {
    static_assert(is_defined());
    return traits().is_deleted;
  }
};

// A helper class for possibly polymorphic methods.
template<reflection_t X>
struct polymethod : method<X> {
  static constexpr bool is_virtual() {
    return method<X>::traits().is_virtual;
  }
  static constexpr bool is_pure_virtual() {
    return method<X>::traits().is_abstract;
  }
  static constexpr bool is_final() {
    return method<X>::traits().is_final;
  }
  static constexpr bool is_override() {
    return method<X>::traits().is_override;
  }
};

// A constructor is a special member function.
template<reflection_t X>
struct constructor : method<X> {
  static constexpr bool is_constexpr() {
    return method<X>::traits().is_constexpr;
  }
  static constexpr bool is_explicit() {
    return method<X>::traits().is_explicit;
  }

  static constexpr bool is_defaulted() {
    static_assert(method<X>::is_defined());
    return method<X>::traits().is_deleted;
  }
  static constexpr bool is_trivial() {
    static_assert(method<X>::is_defined());
    return method<X>::traits().is_deleted;
  }
  static constexpr bool is_copy() {
    return method<X>::traits().is_copy_ctor;
  }
  static constexpr bool is_move() {
    return method<X>::traits().is_move_ctor;
  }
};

// A destructor is a special member function that can be overridden.
template<reflection_t X>
struct destructor : polymethod<X>
{
  static constexpr bool is_defaulted() {
    static_assert(polymethod<X>::is_defined());
    return polymethod<X>::traits().is_deleted;
  }
  static constexpr bool is_trivial() {
    static_assert(polymethod<X>::is_defined());
    return polymethod<X>::traits().is_deleted;
  }
};

// Non-special member functions.
template<reflection_t X>
struct member_function : polymethod<X>
{
  static constexpr bool is_constexpr() {
    return polymethod<X>::traits().is_constexpr;
  }
  static constexpr bool is_copy_assignment_operator() {
    return polymethod<X>::traits().is_copy_assign;
  }
  static constexpr bool is_move_assignment_operator() {
    return polymethod<X>::traits().is_move_assign;
  }

  static constexpr void make_virtual() {
    __modify_virtual(X, false);
  }
  static constexpr void make_pure_virtual() {
    __modify_virtual(X, true);
  }
};

// Conversion operators.
template<reflection_t X>
struct conversion_function : member_function<X>
{
  static constexpr bool is_constexpr() {
    return member_function<X>::traits().is_constexpr;
  }
  static constexpr bool is_explicit() {
    return member_function<X>::traits().is_explicit;
  }
};

// A member variable is a non-static data member.
template<reflection_t X>
struct member_variable : named<X>, typed<X> {
  static constexpr field_traits traits() {
    return field_traits(__reflect_traits(X));
  }

  static constexpr bool is_mutable() {
    return traits().is_mutable;
  }

  static constexpr auto pointer() {
    return __reflect_pointer(X);
  }
};

// A function parameter is essentially a variable.
template<reflection_t X>
struct parameter : variable<X>
{
};

// An enumeration value.
//
// NOTE: Value traits do not currently differ from decl traits.
template<reflection_t X>
struct enumerator : named<X>, typed<X>
{
  static constexpr auto value() {
    return __reflect_value(X);
  }
};

// -------------------------------------------------------------------------- //
// Tuple traversal/application

template<typename T, typename F>
constexpr void
for_each(T const& t, F f) {
  detail::tuple_for_each_recursive<0>(t, f);
}

// -------------------------------------------------------------------------- //
// Type traits

// is internal
//
// True for any internally generated AST nodes. These are typically filtered
// from sequences by the is_observable trait.

template<typename T>
struct is_internal
  : std::integral_constant<bool, false> { };

template<reflection_t X>
struct is_internal<internal<X>>
  : std::integral_constant<bool, true> { };

// is observable
//
// True for all non-internal nodes.

template<typename T>
struct is_observable_trait
  : std::integral_constant<bool, !is_internal<T>::value> { };

template<typename T>
constexpr bool is_observable_v = is_observable_trait<T>::value;

template<typename T>
constexpr bool is_observable(T) {
  return is_observable_v<T>;
}

// is variable

template<typename T>
struct is_variable_trait
  : std::integral_constant<bool, false> { };

template<reflection_t X>
struct is_variable_trait<variable<X>>
  : std::integral_constant<bool, true> { };

template<typename T>
constexpr bool is_variable_v = is_variable_trait<T>::value;

template<typename T>
constexpr bool is_variable(T) {
  return is_variable_v<T>;
}

// is function

template<typename T>
struct is_function_trait
  : std::integral_constant<bool, false> { };

template<reflection_t X>
struct is_function_trait<function<X>>
  : std::integral_constant<bool, true> { };

template<typename T>
constexpr bool is_function_v = is_function_trait<T>::value;

template<typename T>
constexpr bool is_function(T) {
  return is_function_v<T>;
}

// is member variable

template<typename T>
struct is_member_variable_trait
  : std::integral_constant<bool, false> { };

template<reflection_t X>
struct is_member_variable_trait<member_variable<X>>
  : std::integral_constant<bool, true> { };

template<typename T>
constexpr bool is_member_variable_v = is_member_variable_trait<T>::value;

template<typename T>
constexpr bool is_member_variable(T) {
  return is_member_variable_v<T>;
}

// is member function

template<typename T>
struct is_member_function_trait
  : std::integral_constant<bool, false> { };

template<reflection_t X>
struct is_member_function_trait<member_function<X>>
  : std::integral_constant<bool, true> { };

template<typename T>
constexpr bool is_member_function_v = is_member_function_trait<T>::value;

template<typename T>
constexpr bool is_member_function(T) {
  return is_member_function_v<T>;
}

// is constructor

template<typename T>
struct is_constructor_trait
  : std::integral_constant<bool, false> { };

template<reflection_t X>
struct is_constructor_trait<constructor<X>>
  : std::integral_constant<bool, true> { };

template<typename T>
constexpr bool is_constructor_v = is_constructor_trait<T>::value;

template<typename T>
constexpr bool is_constructor(T) {
  return is_constructor_v<T>;
}

// is destructor

template<typename T>
struct is_destructor_trait
  : std::integral_constant<bool, false> { };

template<reflection_t X>
struct is_destructor_trait<destructor<X>>
  : std::integral_constant<bool, true> { };

template<typename T>
constexpr bool is_destructor_v = is_destructor_trait<T>::value;

template<typename T>
constexpr bool is_destructor(T) {
  return is_destructor_v<T>;
}

// is function or method
//
// True for any (possibly static) member variable.

template<typename T>
struct is_function_or_method_trait
  : std::integral_constant<bool, false> { };

template<reflection_t X>
struct is_function_or_method_trait<function<X>>
  : std::integral_constant<bool, true> { };

template<reflection_t X>
struct is_function_or_method_trait<member_function<X>>
  : std::integral_constant<bool, true> { };

template<typename T>
constexpr bool is_function_or_method_v = is_function_or_method_trait<T>::value;

template<typename T>
constexpr bool is_function_or_method(T) {
  return is_function_or_method_v<T>;
}

// is variable or field
//
// True for any (possibly static) member variable.

template<typename T>
struct is_variable_or_field_trait
  : std::integral_constant<bool, false> { };

template<reflection_t X>
struct is_variable_or_field_trait<variable<X>>
  : std::integral_constant<bool, true> { };

template<reflection_t X>
struct is_variable_or_field_trait<member_variable<X>>
  : std::integral_constant<bool, true> { };

template<typename T>
constexpr bool is_variable_or_field_v = is_variable_or_field_trait<T>::value;

template<typename T>
constexpr bool is_variable_or_field(T) {
  return is_variable_or_field_v<T>;
}

} // inline namespace v1
} // namespace meta
} // namespace cppx


namespace std
{

// Tuple adaptors for class_type

template<cppx::meta::reflection_t X>
struct tuple_size<cppx::meta::class_type<X>>
  : std::integral_constant<std::size_t, cppx::meta::class_type<X>::size()>
{ };

template<std::size_t I, cppx::meta::reflection_t X>
struct tuple_element<I, cppx::meta::class_type<X>>
{
  using type = decltype(get<I>(std::declval<cppx::meta::class_type<X>>().members()));
};

// Tuple adaptors for union_type

template<cppx::meta::reflection_t X>
struct tuple_size<cppx::meta::union_type<X>>
  : std::integral_constant<std::size_t, cppx::meta::union_type<X>::size()>
{ };

template<std::size_t I, cppx::meta::reflection_t X>
struct tuple_element<I, cppx::meta::union_type<X>>
{
  using type = decltype(get<I>(std::declval<cppx::meta::union_type<X>>().members()));
};

// Tuple adaptors for enum_type

template<cppx::meta::reflection_t X>
struct tuple_size<cppx::meta::enum_type<X>>
  : std::integral_constant<std::size_t, cppx::meta::enum_type<X>::size()>
{ };

template<std::size_t I, cppx::meta::reflection_t X>
struct tuple_element<I, cppx::meta::enum_type<X>>
{
  using type = decltype(get<I>(std::declval<cppx::meta::enum_type<X>>().members()));
};

// Tuple adaptors for ns

template<cppx::meta::reflection_t X>
struct tuple_size<cppx::meta::ns<X>>
  : std::integral_constant<std::size_t, cppx::meta::ns<X>::size()>
{ };

template<std::size_t I, cppx::meta::reflection_t X>
struct tuple_element<I, cppx::meta::ns<X>>
{
  using type = decltype(get<I>(std::declval<cppx::meta::ns<X>>().members()));
};

// Tuple adaptors for tu

template<cppx::meta::reflection_t X>
struct tuple_size<cppx::meta::tu<X>>
  : std::integral_constant<std::size_t, cppx::meta::tu<X>::size()>
{ };

template<std::size_t I, cppx::meta::reflection_t X>
struct tuple_element<I, cppx::meta::tu<X>>
{
  using type = decltype(get<I>(std::declval<cppx::meta::tu<X>>().members()));
};

} // namespace std

#endif // CPPX_META
